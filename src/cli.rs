use std::ffi::OsString;

use argh::FromArgs;

xflags::xflags! {
    src "./src/cli.rs"

    /// Tool to connect to WebSocket, listen them and do other network tricks
    cmd websocat-args {
        required spec1: String
    
        optional spec2: String
    
        /// do not execute this Websocat invocation, print equivalent Rhai script instead.
        optional --dump_spec
    
        /// do not execute this Websocat invocation, print debug representation of specified arguments.
        optional --dump-spec-phase1
    
        /// do not execute this Websocat invocation, print debug representation of specified arguments.
        optional --dump-spec-phase2
    
        /// execute specified file as Rhai script (e.g. resutling from --dump-spec option output)
        optional -x,--scenario
    
        /// use text mode (one line = one WebSocket text message)
        optional -t,--text
    
        /// use binary mode (arbitrary byte chunk = one WebSocket binary message)
        optional -b,--binary
    
        /// resolve hostnames to IP addresses late (every time when forwarding a connection) instead of one time at the beginning
        optional --late-resolve
    
        /// accept invalid domains and root certificates for TLS client connections
        optional -k,--insecure
    
        /// manually specify domain for `tls:` overlay or override domain for `wss://` URLs
        optional --tls-domain tls_domain: String
    
        /// qqq
        repeated --qqq qqq: OsString
    }
}
// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct WebsocatArgs {
    pub spec1: String,
    pub spec2: Option<String>,

    pub dump_spec: bool,
    pub dump_spec_phase1: bool,
    pub dump_spec_phase2: bool,
    pub scenario: bool,
    pub text: bool,
    pub binary: bool,
    pub late_resolve: bool,
    pub insecure: bool,
    pub tls_domain: Option<String>,
    pub qqq: Vec<OsString>,
}

impl WebsocatArgs {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
/* 
#[derive(FromArgs, Debug)]
/// Tool to connect to WebSocket, listen them and do other network tricks
pub struct WebsocatArgs {
    #[argh(positional)]
    pub spec1: String,

    #[argh(positional)]
    pub spec2: Option<String>,

    /// do not execute this Websocat invocation, print equivalent Rhai script instead.
    #[argh(switch)]
    pub dump_spec: bool,

    /// do not execute this Websocat invocation, print debug representation of specified arguments.
    #[argh(switch)]
    pub dump_spec_phase1: bool,

    /// do not execute this Websocat invocation, print debug representation of specified arguments.
    #[argh(switch)]
    pub dump_spec_phase2: bool,

    /// execute specified file as Rhai script (e.g. resutling from --dump-spec option output)
    #[argh(switch, short = 'x')]
    pub scenario: bool,

    /// use text mode (one line = one WebSocket text message)
    #[argh(switch, short = 't')]
    pub text: bool,

    /// use binary mode (arbitrary byte chunk = one WebSocket binary message)
    #[argh(switch, short = 'b')]
    pub binary: bool,

    /// resolve hostnames to IP addresses late (every time when forwarding a connection) instead of one time at the beginning
    #[argh(switch)]
    pub late_resolve: bool,

    /// accept invalid domains and root certificates for TLS client connections
    #[argh(switch, short = 'k')]
    pub insecure: bool,

    /// manually specify domain for `tls:` overlay or override domain for `wss://` URLs
    #[argh(option)]
    pub tls_domain: Option<String>,

    /// qqq
    #[argh(option)]
    pub qqq: Option<std::ffi::OsString>,
}
*/
